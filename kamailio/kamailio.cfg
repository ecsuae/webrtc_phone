#!KAMAILIO

# ============================================================
#  kamailio.cfg  (WebRTC WS/WSS -> SIP + RTPengine bridge)
#  - Fixes: WebSocket registration (SIP.js) + RTPengine media
#  - Design: Kamailio acts as a PROXY (registrations go to PBX)
#  - Works with Docker: rtpengine reachable as "rtpengine:22222"
#
#  ENV you can set in docker-compose for kamailio container:
#    PBX_HOST=fusn04.srve.cc
#    PBX_PORT=5060
#    KAM_PUBLIC_IP=85.235.64.159   (optional but recommended)
#
#  Ports expected:
#    - UDP/TCP 5060 for SIP (optional, but useful)
#    - WS 8443 (your reverse proxy may terminate TLS and forward to this)
#
#  NOTE:
#    - If you terminate TLS at Nginx/Traefik, Kamailio only needs WS (not WSS).
# ============================================================

####### Global Parameters #########

debug=3
log_stderror=yes

memdbg=5
memlog=5

# Allow TCP requests without Content-Length (needed for WebSocket handshakes)
tcp_accept_no_cl=1

fork=yes
children=8

# --- If you have a public IP, set it via env KAM_PUBLIC_IP, otherwise comment out.
#     In Docker behind NAT, this helps correct Via/Contact handling.
#!ifdef KAM_PUBLIC_IP
alias="$env(KAM_PUBLIC_IP)"
#!endif

# Listen SIP
listen=udp:0.0.0.0:5060
listen=tcp:0.0.0.0:5060

# Listen WebSocket (reverse proxy -> ws://kamailio:8443)
# Fallback to TCP if WS transport is not compiled in.
listen=tcp:0.0.0.0:8443

# DNS / Resolver
dns_try_ipv6=no
auto_aliases=no

# ============================================================
# Modules
# ============================================================

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "pv.so"
loadmodule "kex.so"

# WebSocket
loadmodule "xhttp.so"
loadmodule "websocket.so"

# NAT helpers
loadmodule "nathelper.so"

# RTPengine
loadmodule "rtpengine.so"

loadmodule "sanity.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"

loadmodule "path.so"
loadmodule "outbound.so"

# ============================================================
# Module Parameters
# ============================================================

# --- tm ---
modparam("tm", "fr_timer", 5000)
modparam("tm", "fr_inv_timer", 30000)
modparam("tm", "restart_fr_on_each_reply", 0)


# --- rr ---
modparam("rr", "enable_full_lr", 1)

# --- websocket ---
# Keep WS connections stable
modparam("websocket", "keepalive_mechanism", 1)     # ping/pong
modparam("websocket", "keepalive_timeout", 30)


# --- nathelper ---
modparam("nathelper", "natping_interval", 0)
modparam("nathelper", "ping_nated_only", 1)

# --- rtpengine ---
# Docker service name "rtpengine" + control port 22222
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:22222")

modparam("sanity", "autodrop", 0)

modparam("usrloc", "db_mode", 0)

modparam("registrar", "received_avp", "$avp(received)")

modparam("nathelper", "received_avp", "$avp(received)")

# --- path ---
modparam("path", "use_received", 1)


# ============================================================
# Routing Logic
# ============================================================

# Where to send SIP signaling (your FusionPBX)
# Defaults are used when env vars are unset.
#!define PBX_HOST "fusn04.srve.cc"
#!define PBX_PORT "5060"

# ------------------------------------------------------------
# Main Request Route
# ------------------------------------------------------------
# --- usrloc / registrar must share the same received_avp ---
modparam("registrar", "received_avp", "$avp(received)")

# nathelper fix_nated_register() requires nathelper received_avp too
modparam("nathelper", "received_avp", "$avp(received)")

# ============================================================
# WebSocket HTTP handler (MANDATORY)
# ============================================================
# ============================================================
# WebSocket HTTP handler (ONLY ONE - do not duplicate)
# ============================================================
event_route[xhttp:request] {
    xlog("L_INFO", "HTTP request $rm from $si:$sp to $hu (port=$Rp)\n");

    # Only allow HTTP/WS on the WS listen port
    if ($Rp != 8443) {
        xhttp_reply("403", "Forbidden", "text/plain", "Forbidden\n");
        exit;
    }

    # WebSocket handshake
    if ($rm == "GET" && ($hdr(Upgrade) =~ "websocket" || $hdr(Connection) =~ "Upgrade")) {
        ws_handle_handshake();
        exit;
    }

    # Everything else
    xhttp_reply("404", "Not Found", "text/plain", "Not Found\n");
    exit;
}

request_route {
    # If PBX sends a request to a Contact with ;alias=... (WS flow token),
  # this restores the correct destination (the active WS connection).
  handle_ruri_alias();

    # --- WebSocket SIP ---
    if ($proto == "ws" || $proto == "wss") {
        if (!has_totag()) {
            xlog("L_INFO", "WS SIP $rm from $si:$sp\n");
        }
        force_rport();
        set_contact_alias();
    }

    # --- sanity ---
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if ($rm == "OPTIONS" && $ru == "sip:ping@kamailio") {
        sl_send_reply("200", "OK");
        exit;
    }

    # --- drop invalid ---
    if (!sanity_check("1511", "7")) {
        sl_send_reply("400", "Bad Request");
        exit;
    }

    # --- NAT / WS helpers ---
    # For WS clients, SIP.js needs contact alias so responses can find the same WS connection.
    if ($proto =~ "ws") {
        set_contact_alias();
    }

    # REGISTER
    if (is_method("REGISTER")) {

    route(FIX_NAT_REGISTER);

    # Make PBX route back via this proxy (RFC 3327 Path)
    add_path_received();

    # Ensure WS flow token (alias) is present so replies/INVITEs can find the WS socket
    set_contact_alias();

    route(RELAY_TO_PBX);
    exit;
}

    # In-dialog requests (ACK/BYE/re-INVITE)
    if (has_totag()) {
        route(WITHIN_DIALOG);
        exit;
    }

    # Handle CANCEL quickly
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # New INVITE: record-route + media offer
    if (is_method("INVITE")) {
        record_route();

        # If INVITE has SDP, anchor/bridge media via rtpengine
        if (has_body("application/sdp")) {
            route(MEDIA_OFFER);
        }
    }

    # Subscribe/Refer: still record-route for dialog correctness
    if (is_method("SUBSCRIBE|REFER")) {
        record_route();
    }

    # Relay anything else to PBX
    route(RELAY_TO_PBX);
}

# ------------------------------------------------------------
# NAT register fixes
# ------------------------------------------------------------
route[FIX_NAT_REGISTER] {

    # If SIP.js behind NAT: fix contact and ensure alias.
    # (set_contact_alias already done for $proto =~ "ws")
    if (nat_uac_test("19")) {
        fix_nated_register();
    }
    return;
}


# ------------------------------------------------------------
# In-dialog routing
# ------------------------------------------------------------
route[WITHIN_DIALOG] {

    if (loose_route()) {

        # If ACK includes SDP, finalize media answer
        if (is_method("ACK") && has_body("application/sdp")) {
            route(MEDIA_ANSWER);
        }

        # BYE: delete rtpengine session
        if (is_method("BYE")) {
            route(MEDIA_DELETE);
        }

        # Keep WS alias
        if ($proto =~ "ws") {
            set_contact_alias();
        }

        route(RELAY);
        exit;
    }

    # No loose_route => not for us
    sl_send_reply("404", "Not Here");
    exit;
}


# ------------------------------------------------------------
# Relay to PBX helper (centralized)
# ------------------------------------------------------------
route[RELAY_TO_PBX] {
    $var(pbx_host) = $env(PBX_IP);
    if ($var(pbx_host) == $null || $var(pbx_host) == "") {
        $var(pbx_host) = $env(PBX_HOST);
    }
    if ($var(pbx_host) == $null || $var(pbx_host) == "") {
        $var(pbx_host) = PBX_HOST;
    }
    $var(pbx_port) = $env(PBX_PORT);
    if ($var(pbx_port) == $null || $var(pbx_port) == "") {
        $var(pbx_port) = PBX_PORT;
    }
    $var(pbx_transport) = $env(PBX_TRANSPORT);
    if ($var(pbx_transport) == $null || $var(pbx_transport) == "") {
        $var(pbx_transport) = "udp";
    }

    xlog("L_INFO", "RELAY_TO_PBX via $var(pbx_transport) to $var(pbx_host):$var(pbx_port) from $si:$sp\n");

    # Send everything to FusionPBX (registrations and calls)
    $du = "sip:" + $var(pbx_host) + ":" + $var(pbx_port) + ";transport=" + $var(pbx_transport);

    # Let us touch replies (useful for SDP answer)
    t_on_reply("MANAGE_REPLY");

    route(RELAY);
    exit;
}


# ------------------------------------------------------------
# Actual relay
# ------------------------------------------------------------
route[RELAY] {

    # Required for stateful forwarding
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}


# ------------------------------------------------------------
# Reply route (handles 200 OK SDP, etc.)
# ------------------------------------------------------------
onreply_route[MANAGE_REPLY] {

    # Keep WS aliasing stable for replies too
    if ($proto =~ "ws") {
        set_contact_alias();
    }

    # When PBX replies with SDP (e.g., 183/200), bridge with rtpengine_answer
    if (status=~"18[0-9]|2[0-9][0-9]" && has_body("application/sdp")) {
        route(MEDIA_ANSWER);
    }

    exit;
}


# ============================================================
# RTPENGINE MEDIA ROUTES
# ============================================================

route[MEDIA_OFFER] {
    xlog("L_INFO", "MEDIA_OFFER rtpengine_offer() from $si:$sp proto=$proto\n");

    # We remove ICE toward PBX leg and ensure correct c= / o= rewriting.
    # If PBX supports ICE, you can remove ICE=remove.
    rtpengine_offer("replace-origin replace-session-connection ICE=remove RTP/AVP");

    exit;
}

route[MEDIA_ANSWER] {
    xlog("L_INFO", "MEDIA_ANSWER rtpengine_answer() from $si:$sp proto=$proto\n");

    rtpengine_answer("replace-origin replace-session-connection ICE=remove RTP/AVP");

    exit;
}

route[MEDIA_DELETE] {
    xlog("L_INFO", "MEDIA_DELETE rtpengine_delete()\n");
    rtpengine_delete();
    exit;
}