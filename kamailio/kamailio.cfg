#!KAMAILIO

# ============================================================
# Use PUBLIC_IP from .env file (set in docker-compose environment)
# Fallback to 127.0.0.1 if not set
#!ifdef PUBLIC_IP
#!define KAM_PUBLIC_IP "$env(PUBLIC_IP)"
#!else
#!define KAM_PUBLIC_IP "127.0.0.1"
#!endif

####### Global Parameters #########

debug=3;
log_stderror=yes;

memdbg=5;
memlog=5;

tcp_accept_no_cl=1;

fork=yes;
children=8;

# define macro once (donâ€™t double-define it)
#!define KAM_PUBLIC_IP "$env(PUBLIC_IP)"

# alias should expand to the IP (or remove alias completely)
alias=KAM_PUBLIC_IP;

listen=udp:0.0.0.0:5060 advertise KAM_PUBLIC_IP:5060;
listen=tcp:0.0.0.0:5060 advertise KAM_PUBLIC_IP:5060;

listen=ws:0.0.0.0:8443;

dns_try_ipv6=no;
auto_aliases=no;

# ============================================================
# Modules
# ============================================================

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "pv.so"
loadmodule "kex.so"

# WebSocket
loadmodule "xhttp.so"
loadmodule "websocket.so"

# NAT helpers
loadmodule "nathelper.so"

# RTPengine
loadmodule "rtpengine.so"

loadmodule "sanity.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"

loadmodule "path.so"
loadmodule "outbound.so"


# ============================================================
# Module Parameters
# ============================================================

# --- tm ---
modparam("tm", "fr_timer", 5000)
modparam("tm", "fr_inv_timer", 30000)
modparam("tm", "restart_fr_on_each_reply", 0)

# --- rr ---
modparam("rr", "enable_full_lr", 1)

# --- websocket ---
modparam("websocket", "keepalive_mechanism", 1)     # ping/pong
modparam("websocket", "keepalive_timeout", 30)

# --- nathelper ---
modparam("nathelper", "natping_interval", 0)
modparam("nathelper", "ping_nated_only", 1)

# --- rtpengine ---
# IMPORTANT: Your RTPengine listens on 2223 (NOT 2223)
# Docker service name "rtpengine" + NG control port 2223
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:2223")

modparam("sanity", "autodrop", 0)
modparam("usrloc", "db_mode", 0)

# --- registrar/nathelper received avp ---
modparam("registrar", "received_avp", "$avp(received)")
modparam("nathelper", "received_avp", "$avp(received)")

# --- path ---
modparam("path", "use_received", 1)


# ============================================================
# WebSocket HTTP handler (ONLY ONE - do not duplicate)
# ============================================================
event_route[xhttp:request] {
    xlog("L_INFO", "HTTP request $rm from $si:$sp to $hu (port=$Rp)\n");

    if ($rm == "GET" && ($hdr(Upgrade) =~ "websocket" || $hdr(Connection) =~ "Upgrade")) {
        ws_handle_handshake();
        exit;
    }

    xhttp_reply("404", "Not Found", "text/plain", "Not Found\n");
    exit;
}


# ============================================================
# Main Routing Logic
# ============================================================
request_route {
    # If PBX sends a request to a Contact with ;alias=... (WS flow token),
    # this restores the correct destination (the active WS connection).
    handle_ruri_alias();

    # --- WebSocket SIP ---
    if ($proto == "ws" || $proto == "wss") {
        if (!has_totag()) {
            xlog("L_INFO", "WS SIP $rm from $si:$sp\n");
        }
        force_rport();
        if (is_present_hf("Contact") && !($hdr(Contact) =~ "alias=")) {
            set_contact_alias();
        }
    }

    # --- sanity / maxfwd ---
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if ($rm == "OPTIONS" && $ru == "sip:ping@kamailio") {
        sl_send_reply("200", "OK");
        exit;
    }

    if (!sanity_check("1511", "7")) {
        sl_send_reply("400", "Bad Request");
        exit;
    }

    # REGISTER
    if (is_method("REGISTER")) {
        route(FIX_NAT_REGISTER);
        add_path_received();
        route(RELAY_TO_PBX);
        exit;
    }

    # In-dialog
    if (has_totag()) {
        route(WITHIN_DIALOG);
        exit;
    }

    # CANCEL
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # New INVITE
    if (is_method("INVITE")) {
        record_route();

        # Ensure we always catch 18x/200 replies with SDP
        t_on_reply("MANAGE_REPLY");

        if (has_body("application/sdp")) {
            route(MEDIA_OFFER);
        }

        route(RELAY_TO_PBX);
        exit;
    }

    # Subscribe/Refer: keep dialog correctness
    if (is_method("SUBSCRIBE|REFER")) {
        record_route();
    }

    # Anything else -> PBX
    route(RELAY_TO_PBX);
}


# ------------------------------------------------------------
# NAT register fixes
# ------------------------------------------------------------
route[FIX_NAT_REGISTER] {
    if (nat_uac_test("19")) {
        fix_nated_register();
    }
    return;
}


# ------------------------------------------------------------
# In-dialog routing
# ------------------------------------------------------------
route[WITHIN_DIALOG] {
    if (loose_route()) {

        # re-INVITE with SDP (or UPDATE with SDP)
        if (is_method("INVITE|UPDATE") && has_body("application/sdp")) {
            route(MEDIA_OFFER);
        }

        # ACK with SDP (rare but possible)
        if (is_method("ACK") && has_body("application/sdp")) {
            route(MEDIA_ANSWER);
        }

        # BYE: cleanup rtpengine session
        if (is_method("BYE")) {
            route(MEDIA_DELETE);
        }

        route(RELAY);
        exit;
    }

    # Fallback for endpoints that do not honor Record-Route
    if (is_method("BYE|ACK|CANCEL")) {
        route(RELAY);
        exit;
    }

    sl_send_reply("404", "Not Here");
    exit;
}


# ------------------------------------------------------------
# Relay to PBX helper
# ------------------------------------------------------------
route[RELAY_TO_PBX] {
    $var(pbx_host) = $env(PBX_IP);
    if ($var(pbx_host) == $null || $var(pbx_host) == "") {
        xlog("L_ERR", "RELAY_TO_PBX: PBX_IP not set in environment\n");
        sl_send_reply("500", "Server Error - PBX not configured");
        exit;
    }

    $var(pbx_port) = $env(PBX_PORT);
    if ($var(pbx_port) == $null || $var(pbx_port) == "") {
        $var(pbx_port) = "5060";
    }

    $var(pbx_transport) = $env(PBX_TRANSPORT);
    if ($var(pbx_transport) == $null || $var(pbx_transport) == "") {
        $var(pbx_transport) = "udp";
    }

    xlog("L_INFO", "RELAY_TO_PBX via $var(pbx_transport) to $var(pbx_host):$var(pbx_port) from $si:$sp\n");

    $du = "sip:" + $var(pbx_host) + ":" + $var(pbx_port) + ";transport=" + $var(pbx_transport);

    # touch replies to handle SDP answers
    t_on_reply("MANAGE_REPLY");

    route(RELAY);
    exit;
}


# ------------------------------------------------------------
# Actual relay
# ------------------------------------------------------------
route[RELAY] {
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}


# ------------------------------------------------------------
# Reply route (handles 183/200 SDP from PBX)
# ------------------------------------------------------------
onreply_route[MANAGE_REPLY] {
    if ($proto =~ "ws") {
        set_contact_alias();
    }

    if (status=~"18[0-9]|2[0-9][0-9]" && has_body("application/sdp")) {
        route(MEDIA_ANSWER);
    }

    exit;
}


# ============================================================
# RTPENGINE MEDIA ROUTES (ENABLED)
# ============================================================

route[MEDIA_OFFER] {
    if (!has_body("application/sdp")) return;

    xlog("L_INFO", "MEDIA_OFFER: rtpengine_offer() for $rm ci=$ci proto=$proto from=$si:$sp\n");

    # Offer is going TO the PBX -> make it plain RTP (no ICE/DTLS)
    if (!rtpengine_offer("trust-address replace-origin replace-session-connection ICE=remove DTLS=off RTP/AVP")) {
        xlog("L_ERR", "MEDIA_OFFER: rtpengine_offer() failed for ci=$ci\n");
    }
    return;
}


route[MEDIA_ANSWER] {
    if (!has_body("application/sdp")) return;

    xlog("L_INFO", "MEDIA_ANSWER: rtpengine_answer() for reply $rs ci=$ci\n");

    # Same flags on answer.
    if (!rtpengine_answer("trust-address replace-origin replace-session-connection ICE=force DTLS=passive")) {
        xlog("L_ERR", "MEDIA_ANSWER: rtpengine_answer() failed for ci=$ci\n");
    }
    return;
}

route[MEDIA_DELETE] {
    xlog("L_INFO", "MEDIA_DELETE: rtpengine_delete() ci=$ci\n");
    rtpengine_delete();
    return;
}