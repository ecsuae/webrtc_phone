#!KAMAILIO

# ============================================================
# Use PUBLIC_IP from .env file (set in docker-compose environment)
# Fallback to 127.0.0.1 if not set
#!ifdef PUBLIC_IP
#!define KAM_PUBLIC_IP "$env(PUBLIC_IP)"
#!else
#!define KAM_PUBLIC_IP "127.0.0.1"
#!endif

#  kamailio.cfg  (WebRTC WS/WSS -> SIP + RTPengine bridge)
#  - Fixes: WebSocket registration (SIP.js) + RTPengine media
#  - Design: Kamailio acts as a PROXY (registrations go to PBX)
#  - Works with Docker: rtpengine reachable as "rtpengine:22222"
#
#  ENV you can set in docker-compose for kamailio container:
#    PUBLIC_IP=your.public.ip       (e.g., 38.242.157.239)
#    PBX_IP=your.pbx.ip             (e.g., 85.235.64.159)
#    PBX_PORT=5060
#
#  Ports expected:
#    - UDP/TCP 5060 for SIP (optional, but useful)
#    - WS 8443 (your reverse proxy may terminate TLS and forward to this)
#
#  NOTE:
#    - If you terminate TLS at Nginx/Traefik, Kamailio only needs WS (not WSS).
# ============================================================

####### Global Parameters #########

debug=3
log_stderror=yes

memdbg=5
memlog=5

# Allow TCP requests without Content-Length (needed for WebSocket handshakes)
tcp_accept_no_cl=1

fork=yes
children=8

# --- If you have a public IP, set it via env PUBLIC_IP, otherwise comment out.
#     In Docker behind NAT, this helps correct Via/Contact handling.
#!ifdef PUBLIC_IP
alias="$env(PUBLIC_IP)"
#!endif

# Listen SIP
listen=udp:0.0.0.0:5060 advertise KAM_PUBLIC_IP:5060
listen=tcp:0.0.0.0:5060 advertise KAM_PUBLIC_IP:5060

# Listen WebSocket
# TCP on 8443 for WebSocket (nginx terminates TLS and proxies http here)
listen=tcp:0.0.0.0:8443

# DNS / Resolver
dns_try_ipv6=no
auto_aliases=no

# ============================================================
# Modules
# ============================================================

loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "rr.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "pv.so"
loadmodule "kex.so"

# WebSocket
loadmodule "xhttp.so"
loadmodule "websocket.so"

# NAT helpers
loadmodule "nathelper.so"

# RTPengine
loadmodule "rtpengine.so"

loadmodule "sanity.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"

loadmodule "path.so"
loadmodule "outbound.so"

# ============================================================
# Module Parameters
# ============================================================

# --- tm ---
modparam("tm", "fr_timer", 5000)
modparam("tm", "fr_inv_timer", 30000)
modparam("tm", "restart_fr_on_each_reply", 0)

# --- rr ---
modparam("rr", "enable_full_lr", 1)

# --- websocket ---
# Keep WS connections stable
modparam("websocket", "keepalive_mechanism", 1)     # ping/pong
modparam("websocket", "keepalive_timeout", 30)

# --- nathelper ---
modparam("nathelper", "natping_interval", 0)
modparam("nathelper", "ping_nated_only", 1)

# --- rtpengine ---
# Docker service name "rtpengine" + control port 22222
modparam("rtpengine", "rtpengine_sock", "udp:rtpengine:22222")

modparam("sanity", "autodrop", 0)

modparam("usrloc", "db_mode", 0)

modparam("registrar", "received_avp", "$avp(received)")

modparam("nathelper", "received_avp", "$avp(received)")

# --- path ---
modparam("path", "use_received", 1)


# ============================================================
# Routing Logic
# ============================================================

# Where to send SIP signaling (your FusionPBX)
# Use environment variables from docker-compose
# PBX_IP, PBX_PORT, PBX_TRANSPORT are set via env_file

# ------------------------------------------------------------
# Main Request Route
# ------------------------------------------------------------
# --- usrloc / registrar must share the same received_avp ---
modparam("registrar", "received_avp", "$avp(received)")

# nathelper fix_nated_register() requires nathelper received_avp too
modparam("nathelper", "received_avp", "$avp(received)")

# ============================================================
# WebSocket HTTP handler (MANDATORY)
# ============================================================
# ============================================================
# WebSocket HTTP handler (ONLY ONE - do not duplicate)
# ============================================================
event_route[xhttp:request] {
    xlog("L_INFO", "HTTP request $rm from $si:$sp to $hu (port=$Rp)\n");


    # WebSocket handshake
    if ($rm == "GET" && ($hdr(Upgrade) =~ "websocket" || $hdr(Connection) =~ "Upgrade")) {
        ws_handle_handshake();
        exit;
    }

    # Everything else
    xhttp_reply("404", "Not Found", "text/plain", "Not Found\n");
    exit;
}

request_route {
    # If PBX sends a request to a Contact with ;alias=... (WS flow token),
  # this restores the correct destination (the active WS connection).
  handle_ruri_alias();

    # --- WebSocket SIP ---
    if ($proto == "ws" || $proto == "wss") {
        if (!has_totag()) {
            xlog("L_INFO", "WS SIP $rm from $si:$sp\n");
        }
        force_rport();
        if (is_present_hf("Contact") && !($hdr(Contact) =~ "alias=")) {
            set_contact_alias();
        }
    }

    # --- sanity ---
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    if ($rm == "OPTIONS" && $ru == "sip:ping@kamailio") {
        sl_send_reply("200", "OK");
        exit;
    }

    # --- drop invalid ---
    if (!sanity_check("1511", "7")) {
        sl_send_reply("400", "Bad Request");
        exit;
    }

    # REGISTER
    if (is_method("REGISTER")) {

    route(FIX_NAT_REGISTER);

    # Make PBX route back via this proxy (RFC 3327 Path)
    add_path_received();

    route(RELAY_TO_PBX);
    exit;
}

    # In-dialog requests (ACK/BYE/re-INVITE)
    if (has_totag()) {
        route(WITHIN_DIALOG);
        exit;
    }

    # Handle CANCEL quickly
    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            t_relay();
        }
        exit;
    }

    # New INVITE: record-route + media offer
    if (is_method("INVITE")) {
        record_route();

        # If INVITE has SDP, anchor/bridge media via rtpengine
        if (has_body("application/sdp")) {
            route(MEDIA_OFFER);
        }

        # Relay INVITE to PBX
        route(RELAY_TO_PBX);
        exit;
    }

    # Subscribe/Refer: still record-route for dialog correctness
    if (is_method("SUBSCRIBE|REFER")) {
        record_route();
    }

    # Relay anything else to PBX
    route(RELAY_TO_PBX);
}

# ------------------------------------------------------------
# NAT register fixes
# ------------------------------------------------------------
route[FIX_NAT_REGISTER] {

    # If SIP.js behind NAT: fix contact and ensure alias.
    # (set_contact_alias already done for $proto =~ "ws")
    if (nat_uac_test("19")) {
        fix_nated_register();
    }
    return;
}


# ------------------------------------------------------------
# In-dialog routing
# ------------------------------------------------------------
route[WITHIN_DIALOG] {

    if (loose_route()) {

        # If ACK includes SDP, finalize media answer
        if (is_method("ACK") && has_body("application/sdp")) {
            route(MEDIA_ANSWER);
        }

        # BYE: delete rtpengine session
        if (is_method("BYE")) {
            route(MEDIA_DELETE);
        }

        route(RELAY);
        exit;
    }

    # Fallback for endpoints that do not honor Record-Route (e.g., BYE/ACK).
    if (is_method("BYE|ACK|CANCEL")) {
        route(RELAY);
        exit;
    }

    # No loose_route => not for us
    sl_send_reply("404", "Not Here");
    exit;
}


# ------------------------------------------------------------
# Relay to PBX helper (centralized)
# ------------------------------------------------------------
route[RELAY_TO_PBX] {
    $var(pbx_host) = $env(PBX_IP);
    if ($var(pbx_host) == $null || $var(pbx_host) == "") {
        xlog("L_ERR", "RELAY_TO_PBX: PBX_IP not set in environment\n");
        sl_send_reply("500", "Server Error - PBX not configured");
        exit;
    }

    $var(pbx_port) = $env(PBX_PORT);
    if ($var(pbx_port) == $null || $var(pbx_port) == "") {
        $var(pbx_port) = "5060";
    }

    $var(pbx_transport) = $env(PBX_TRANSPORT);
    if ($var(pbx_transport) == $null || $var(pbx_transport) == "") {
        $var(pbx_transport) = "udp";
    }

    xlog("L_INFO", "RELAY_TO_PBX via $var(pbx_transport) to $var(pbx_host):$var(pbx_port) from $si:$sp\n");

    # Send everything to FusionPBX (registrations and calls)
    $du = "sip:" + $var(pbx_host) + ":" + $var(pbx_port) + ";transport=" + $var(pbx_transport);

    # Let us touch replies (useful for SDP answer)
    t_on_reply("MANAGE_REPLY");

    route(RELAY);
    exit;
}


# ------------------------------------------------------------
# Actual relay
# ------------------------------------------------------------
route[RELAY] {

    # Required for stateful forwarding
    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}


# ------------------------------------------------------------
# Reply route (handles 200 OK SDP, etc.)
# ------------------------------------------------------------
onreply_route[MANAGE_REPLY] {

    # Keep WS aliasing stable for replies too
    if ($proto =~ "ws") {
        set_contact_alias();
    }

    # When PBX replies with SDP (e.g., 183/200), bridge with rtpengine_answer
    if (status=~"18[0-9]|2[0-9][0-9]" && has_body("application/sdp")) {
        route(MEDIA_ANSWER);
    }

    exit;
}


# ============================================================
# RTPENGINE MEDIA ROUTES
# ============================================================

route[MEDIA_OFFER] {
    # RTPEngine disabled - passthrough SDP
    xlog("L_INFO", "MEDIA_OFFER: SDP passthrough (no RTPEngine)\n");
    return;
}

route[MEDIA_ANSWER] {
    # RTPEngine disabled - passthrough SDP answer
    xlog("L_INFO", "MEDIA_ANSWER: SDP passthrough\n");
    return;
}

route[MEDIA_DELETE] {
    # RTPEngine disabled - no session cleanup
    xlog("L_INFO", "MEDIA_DELETE: No RTPEngine session\n");
    return;
}
